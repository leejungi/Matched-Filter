import json
import numpy as np
from sklearn.model_selection import train_test_split
from collections import Counter
from PIL import Image

from utils.load import load_data
from utils.log import log

def merge_data(path_json, proportion, verbose=0, calibration=False):
	"""
		Merge data with argument from json. The ground truth is divided with the proportion of train, valid, and atest. The verbose indicate how to split the ground truth.
		Parameters
			- path_json(str): the path of json data.
			- proportion(dict): train, valid, and test proportion. When verbose is 0, the sum of values in proportion should be 1.
			- verbose(int,optional): When verbose is 0, the train, valid, and test data are generated by one HSI. When verbose is 1, each data is generated by different hyperspectral image loaded from the path in json. The data is split by the proportion.
			- calibration(bool, optional): calibration on/off
		Returns
			- data(dict): return hyperspectral data of train, valid, test. The key consists of "train", "valid", and "test". The values have HSIs. The values consist of lists filled with HSI data(numpy).
			- gts(dict): ground truths of each purpose. The values consist of lists filled with ground truth(numpy)
			- imgs(dict): images of each purpose.
	"""

	log(f"Read Data Json file in {path_json}")
	#Read json file
	with open(path_json, "r") as json_file:
		json_data = json.load(json_file)
	log(json.dumps(json_data, indent=4))

	#Load hyperspectral data
	data={}
	gts={}
	imgs={}
	try:
		abs_path=json_data['abs_path']
	except:
		abs_path="./"
		
	for k,v in json_data.items():
		data[k]=[]
		gts[k]=[]
		imgs[k]=[]

	#verbose 0
	log(f"VERBOSE: {verbose}")
	if verbose==0:
		if type(json_data['train']) == list:
			data_path = json_data['train'][0]
		elif type(json_data['train']) == str:
			data_path = json_data['train']
		full_path = abs_path + data_path

		#Split data with respect to the proportion
		assert sum(proportion.values())==1

		datum = load_data(full_path, "data.raw", calibration=calibration)
		gt = load_data(full_path, "label.npy")
		img = Image.open(full_path + "image.png")
			
		#train_gt / valid_gt + test_gt
		train_gt, valid_gt= split_gt(gt, ratio=proportion['train'])
		if proportion['valid'] ==0:
			test_gt = valid_gt
		else:
			#valid_gt / test_gt
			ratio = proportion['valid']/(1-proportion['train'])
			valid_gt, test_gt= split_gt(valid_gt, ratio=ratio)

		gts['train']=[train_gt]
		gts['valid']=[valid_gt]
		gts['test']=[test_gt]

		for k in proportion.keys():
			data[k] = [datum]
		imgs=[img]

	elif verbose in [1,2]:
		for key in proportion:
			log(f"{key.upper()} data")
			pp = proportion[key]
			assert pp <= 1 and pp > 0
			for data_path in json_data[key]:
				full_path = abs_path + data_path

				datum = load_data(full_path, "data.raw", calibration=calibration)
				gt = load_data(full_path, "label.npy")
				if pp < 1:
					if verbose == 2:
						normal_gt = np.where(gt>2,0,gt)
						normal_gt, _ = split_gt(normal_gt, ratio=pp)
						abnormal_gt = np.where(gt<=2,0,gt)
						gt = normal_gt + abnormal_gt
					else:
						gt, _ = split_gt(gt, ratio=pp)
				img = Image.open(full_path + "image.png")

				data[key].append(datum)
				gts[key].append(gt)
				imgs[key].append(img)
				
	#Counting Samples
	train_samples = Counter(np.array(gts['train']).ravel())
	valid_samples = Counter(np.array(gts['valid']).ravel())
	test_samples = Counter(np.array(gts['test']).ravel())

	log("Train samples: {}".format(sum(train_samples.values())-train_samples[0]))
	log(f"\t{train_samples}")
	log("Valid samples: {}".format(sum(valid_samples.values())-valid_samples[0]))
	log(f"\t{valid_samples}")
	log("Test samples: {}".format(sum(test_samples.values())-test_samples[0]))
	log(f"\t{test_samples}")

	return data, gts, imgs


def split_gt(gt, ratio=0.15):
	"""
		Split the input ground truth with respect to the ratio by sklearn.model_selection module.
		Parameters
			- ground truth(numpy): a ground truth(numpy).
			- ratio(float): the ratio of train(first) and test(second) ground truth.
		Returns
			- train_gt(numpy): train(first) ground truth. Some components in the input ground truth are superseded by the 1-ratio.
			- test_gt(numpy): test(second) ground truth. Some components in the input ground truth are superseded by the ratio.
	"""
	indices = np.nonzero(gt) 
	X = list(zip(*indices)) 
	Y = gt[indices].ravel()

	train_gt = np.zeros_like(gt)
	test_gt = np.zeros_like(gt)


	train_indices, test_indices = train_test_split(X, train_size=ratio, stratify=Y) 
	train_indices = tuple([list(t) for t in zip(*train_indices)] )
	test_indices = tuple([list(t) for t in zip(*test_indices)])

	train_gt[train_indices] = gt[train_indices]
	test_gt[test_indices] = gt[test_indices]

	return train_gt, test_gt
